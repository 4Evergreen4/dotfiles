######################
# Evergreen's bashrc #
######################

#########################
# ENVIRONMENT VARIABLES #
#########################

# This script is sourced by bash_profile, so this is a reasonable place to
# put them.  (and it is before the interactivity check)
export EDITOR=vim

# use nvim if it is available
type -P nvim >/dev/null && export EDITOR=nvim

# List of directories to add to PATH if they exist.
path_add=( \
	"$HOME/bin" "$HOME/.gem/ruby/2.3.0/bin" "$HOME/.gem/ruby/2.2.0/bin" \
	"$HOME/.cargo/bin" "$HOME/.cabal/bin" "$HOME/.local/bin" \
)

for dir in "${path_add[@]}"; do
	[[ -d $dir ]] && PATH+=:"$dir"
done
export PATH

# better yaourt colors
export YAOURT_COLORS="nb=1:pkg=1:ver=1;32:lver=1;45:installed=1;42:grp=1;34:od=1;41;5:votes=1;44:dsc=0:other=1;35"

# Shell is non-interactive.  Be done now!
if [[ $- != *i* ]]; then
	return
fi

#############
# FUNCTIONS #
#############

progexists() {
	command -v "$1" >/dev/null 2>&1
	return
}

###########
# OPTIONS #
###########

# Bash won't get SIGWINCH if another process is in the foreground.
# Enable checkwinsize so that bash will check the terminal size when
# it regains control.  #65623
# http://cnswww.cns.cwru.edu/~chet/bash/FAQ (E11)
shopt -s checkwinsize
shopt -s expand_aliases
# moar globbing (don't use this in scripts)
shopt -s extglob
# once again, don't use this in scripts, just use for one-shots
shopt -s globstar
# Enable history appending instead of overwriting.
shopt -s histappend

###########
# ALIASES #
###########

# confirm before overwriting something
alias cp="cp -i"
# human-readable sizes
alias df="df -h"
# editor shortcut
alias e="\$EDITOR"

##########
# COLORS #
##########

use_color=false
use_256color=false
# Check to see if output is a terminal and see if tput exists
if [[ -t 1 ]] && progexists "tput"; then
	# Get number of colors, and set use_color to true if it is greater than 8
	ncolors="$(tput colors)"
	[[ -n $ncolors && $ncolors -ge 8 ]] && use_color=true
	[[ -n $ncolors && $ncolors -ge 256 ]] && use_256color=true
fi

# Set color variables to empty strings so that they will do nothing when in a
# terminal that supports < 8 colors.
RED=""
GREEN=""
YELLOW=""
BLUE=""
MAGENTA=""
CYAN=""
RESET=""
BOLD=""
if ${use_color}; then
	# Do stuff for 8+ color terminals.

	# Set colors for ls using dircolors.  Prefer ~/.dir_colors over
	# /etc/DIR_COLORS, and use defaults if no configs are available.
	if type -P dircolors >/dev/null; then
		if [[ -f ~/.dir_colors ]]; then
			eval $(dircolors -b ~/.dir_colors)
		elif [[ -f /etc/DIR_COLORS ]]; then
			eval $(dircolors -b /etc/DIR_COLORS)
		else
			eval $(dircolors -b)
		fi
	fi

	# Colors for prompt
	# Red
	RED="\[$(tput setaf 1)\]"
	# Green
	GREEN="\[$(tput setaf 2)\]"
	# Yellow
	YELLOW="\[$(tput setaf 3)\]"
	# Blue
	BLUE="\[$(tput setaf 4)\]"
	# Magenta
	MAGENTA="\[$(tput setaf 5)\]"
	# Cyan
	CYAN="\[$(tput setaf 6)\]"
	# Reset
	RESET="\[$(tput sgr0)\]"
	# Bold
	BOLD="\[$(tput bold)\]"

	# Make ls and grep use color.
	alias ls='ls --color=auto'
	alias grep='grep --colour=auto'
	alias egrep='egrep --colour=auto'
	alias fgrep='fgrep --colour=auto'
elif ${use_256color}; then
	# Do stuff for 256+ color terminals

	# Make tmux use 256 colors
	export TERM="screen-256color"
fi

# In the rare case that a terminal supports 256 colors but tput doesn't report
# it, it is safe to assume it supports 256 colors if "256" is in the $TERM
# environment variable.

# Sanitize term by replacing all non-alphanumeric characters with "?".
safe_term=${TERM//[^[:alnum:]]/?}
if [[ "$safe_term" == *"256"* ]]; then 
	export TERM="screen-256color"
fi

##########
# PROMPT #
##########

__ps1_git_branch() {
	if progexists "git" && git branch >/dev/null 2>&1; then
		printf "%s" "$(git rev-parse --abbrev-ref HEAD)"
		return 0
	else
		printf ""
		return 1
	fi
}

__ps1_virtualenv() {
	if [[ -n "$VIRTUAL_ENV" ]]; then
		# Remove trailing slash
		local virtual_env="${VIRTUAL_ENV%/}"
		printf "%s" "${virtual_env##*/}"
		return 0
	else
		printf ""
		return 1
	fi
}

bash_prompt() {
	# Helps separate the prompt from stdout/stderr.
	PS1="\n"

	# Exit code indicator.  Green if zero, red if otherwise.
	local exit_code="$?"
	local exit_color=$GREEN
	[[ "$exit_code" != 0 ]] && local exit_color=$RED
	PS1="$PS1┌(${BOLD}${exit_color}${exit_code}${RESET})-"

	# Username and hostname
	local user_color=$GREEN
	[[ "$UID" == 0 ]] && local user_color=$RED
	PS1="$PS1(${user_color}\u@\H${RESET})"

	# Time and date
	PS1="$PS1-(${BLUE}\D{%H:%M} \d${RESET})"

	# Current git branch
	local git_branch="$(__ps1_git_branch)"
	if [[ -n "$git_branch" ]]; then
		local git_branch="${MAGENTA}${git_branch}${RESET}"
		PS1="$PS1-(${git_branch})"
	fi

	# Current virtualenv
	local virtualenv="$(__ps1_virtualenv)"
	if [[ -n "$virtualenv" ]]; then
		local virtualenv="${YELLOW}${virtualenv}${RESET}"
		PS1="$PS1-(${__ps1_virtualenv})"
	fi

	# Newline.  The $'' notation is necessary due to a bug in msys2 bash.
	PS1="$PS1"$'\n'

	# Working directory
	PS1="$PS1$RESET└(${BOLD}\w${RESET})-"

	# Prefix character before input.
	PS1="$PS1\$ "
}

# Set prompt
PROMPT_COMMAND='bash_prompt'

# Unset variables used for prompt/colors
unset use_color use_256color safe_term

########
# MISC #
########

# Use bash_completion if it is available.
[ -r /usr/share/bash-completion/bash_completion ] && . /usr/share/bash-completion/bash_completion

# Source local settings
[[ -f $HOME/.bashrc.local ]] && source "$HOME/.bashrc.local"

########
# TMUX #
########

if progexists "tmux"; then
	# Automatically attach to a session named after the user if not already in
	# tmux, and create the session if it doesn't exist.
	[[ -z $TMUX ]] && tmux new -A -s "$USER"
fi
