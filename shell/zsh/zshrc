# Evergreen's zshrc #

### ENVIRONMENT VARIABLES ###

if [[ -f "$HOME/.environment" ]]; then
    source "$HOME/.environment"
fi

### COMPLETION ###

# TODO: describe what each option does
zstyle ':completion:*' completer _expand _complete _ignored _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' glob 1
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '+' '+m:{[:lower:]}={[:upper:]}'
zstyle ':completion:*' max-errors 1
zstyle ':completion:*' menu select
zstyle ':completion:*' original true
zstyle ':completion:*' preserve-prefix '//[^/]##/'
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*' substitute 1

### OPTIONS ###

# This makes the vi mode indicator in the prompt update faster
KEYTIMEOUT=1

# History options (pretty self-explanatory)
HISTFILE=~/.histfile
HISTSIZE=10000
SAVEHIST=10000

# Change directories without typing "cd"
setopt autocd

# Corrects my mistakes (and makes me lazier)
setopt correct

# Better globbing for more fun!
setopt extended_glob

# Save extra information about commands in the history
setopt extended_history

# Remove superfluous items from history
setopt hist_expire_dups_first
setopt hist_ignore_dups
setopt hist_ignore_space

# Do history expnasion inline instead of immediately executing
setopt hist_verify

# Add lines to history file as they are entered and share between zsh sessions
setopt inc_append_history

# Immediately select the first option when autocompleting
setopt menu_complete

# Allow command and variable subtitution in prompt
setopt prompt_subst

### ZSH MODULES ###

# Plugins
ZSHRC="$HOME/.zshrc"
# Syntax highlighting
source "${ZSHRC:A:h}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
# Better cd command
export ZSHZ_DATA="$HOME/.config/z"
source "${ZSHRC:A:h}/zsh-z/zsh-z.plugin.zsh"

# Homebrew
if type brew &>/dev/null; then
  FPATH=$(brew --prefix)/share/zsh/site-functions:$FPATH
fi

# Initialize completion system
autoload -Uz compinit
compinit

# Required for menu-completion widget and many other goodies
autoload -Uz complist

# help me
autoload -Uz run-help

# Calculating bliss
autoload -Uz zcalc

### FUNCTIONS ###

function progexists() {
    command -v "$1" >/dev/null 2>&1
    return
}

function notify() {
    eval "$@"
    notify-send "Command Finished" "$*"
}

### KEY BINDINGS ###

# Vi keys pls
bindkey -v

# Cancel completion and undo up to the point when tab was pressed
bindkey -M viins '^g' vi-undo-change

# Make Home and End keys work properly
bindkey '\e[1~' vi-beginning-of-line
bindkey '\eOH' vi-beginning-of-line

# Quickly view help for commands
bindkey -M vicmd 'H' run-help
bindkey -M viins '\eh' run-help

# Do incremental history search instead of non-incremental history search
bindkey -M vicmd '/' history-incremental-search-backward
bindkey -M vicmd '?' history-incremental-search-forward

# Make backspace always delete a character
bindkey -M viins "^?" backward-delete-char

# Shift-tab goes to the previous completion option
bindkey -M viins '^[[Z' reverse-menu-complete

### COLORS ###

#### DETECTION ####

# TODO: write 8 color and 256 color detection algorithm
# For now I'll just be naive
use_color=true
use_256color=true

#### CONFIGURATION ####

if $use_256color; then
    # Do stuff for 256+ color terminals

    if grep -q Microsoft /proc/version; then
        export TERM="xterm-256color"
    else
        # Make tmux use 256 colors
        export TERM="screen-256color"
    fi
fi

if $use_color; then
    # Do stuff for 8+ color terminals.

    # Set colors for ls using dircolors.  Prefer ~/.dir_colors over
    # /etc/DIR_COLORS, and use defaults if no configs are available.
    if [[ -e ~/.dir_colors ]]; then
        eval $(dircolors -b "$HOME/.dir_colors")
    elif [[ -f /etc/DIR_COLORS ]]; then
        eval $(dircolors -b /etc/DIR_COLORS)
    else
        eval $(dircolors -b)
    fi

    # Use the same colors as ls for autocompletion
    zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

    # Make grep use color.
    alias grep='grep --colour=auto'
    alias egrep='egrep --colour=auto'
    alias fgrep='fgrep --colour=auto'

    # Use exa for ls if available
    if progexists exa; then
        alias ls='exa'
        alias l='exa -lbF --git'
        alias ll='exa -lbGF --git'
        alias llm='exa -lbGd --git --sort=modified'
        alias la='exa -lbhHigmuSa --time-style=long-iso --git --color-scale'
        alias lx='exa -lbhHigmuSa@ --time-style=long-iso --git --color-scale'
        alias lS='exa -1'
        alias lt='exa --tree --level=2'
    fi

    # Color man pages
    export LESS_TERMCAP_mb=$'\E[01;32m'
    export LESS_TERMCAP_md=$'\E[01;32m'
    export LESS_TERMCAP_me=$'\E[0m'
    export LESS_TERMCAP_se=$'\E[0m'
    export LESS_TERMCAP_so=$'\E[01;47;34m'
    export LESS_TERMCAP_ue=$'\E[0m'
    export LESS_TERMCAP_us=$'\E[01;36m'
    export LESS=-r
fi

### PROMPT ###

#### VI MODE INDICATOR ####

# See https://superuser.com/questions/151803/how-do-i-customize-zshs-vim-mode/156304
vim_ins_mode="I"
vim_cmd_mode="C"
vim_mode=$vim_ins_mode

function zle-keymap-select {
  vim_mode="${${KEYMAP/vicmd/${vim_cmd_mode}}/(main|viins)/${vim_ins_mode}}"
  zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-finish {
  vim_mode=$vim_ins_mode
}
zle -N zle-line-finish

#### GIT BRANCH ####

function __in_git_repo() {
    progexists "git" && git rev-parse --is-inside-work-tree &>/dev/null
}

function __git_branch() {
    local branch=""
    if __in_git_repo; then
        if git symbolic-ref --short HEAD &>/dev/null; then
            branch="$(git symbolic-ref --short HEAD)"
        else
            local tag="$(git describe --tags --exact-match 2>/dev/null)"
            if [[ -n "$tag" ]]; then
                branch="$tag"
            else
                branch="#$(git rev-parse --short=0 HEAD)"
            fi
        fi
    fi
    [[ -n "$branch" ]] && echo "*%F{magenta}$branch%f"
}

#### VIRTUALENV ####

function __virtualenv() {
    if [[ -n "$VIRTUAL_ENV" ]]; then
        # Remove trailing slash
        local virtual_env="${VIRTUAL_ENV%/}"
        echo " %F{yellow}<${virtual_env##*/}>%f"
        return 0
    else
        printf ""
        return 1
    fi
}

#### SSH HOSTNAME ####

function __is_ssh_session() {
    if [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" ]]; then
        return 0
    else
        case "$(ps -p $PPID | awk 'END {print $4}')" in
            sshd|*/sshd) return 0;;
        esac
    fi

    return 1
}

function __ssh_hostname() {
    if __is_ssh_session; then
        echo " @%F{green}$HOST%f"
    fi
}

#### LEFT PROMPT ####

# This displays the return code of the previous command (green for success, red
# for failure)
PROMPT='%(0?|%F{green}|%F{red})%?%f '

# Displays the current working directory.  If there are 3 or less path
# components, display them as normal.  If there are 4 or more, display the first
# path component, â€¦, then the last 2 components.
PROMPT+='%F{white}%B%(4~|%-1~/.../%2~|%~)%f%b '

# Display "C" for normal mode and "I" for insert mode (for vi keybindings).
PROMPT+='${vim_mode}'

# Color the character directly before the editing line red for root and blue for
# non-root.
PROMPT+='%(!|%F{red}|%F{blue})>%f '

#### RIGHT PROMPT ####

RPROMPT='$(__git_branch)$(__virtualenv)$(__ssh_hostname)'

### ALIASES ###

# Confirm before overwriting
alias cp="cp -i"

# Human readable sizes
alias df="df -h"

# Quick editor shortcut
alias e="\$EDITOR"

# Use the familiar "help" instead of run-help
unalias run-help &>/dev/null
alias help=run-help

### TMUX ###

tmux_user () {
    tmux new -A -s "$USER"
}

alias t="tmux_user"

### MISC ###

# Source local settings
[[ -f $HOME/.zshrc.local ]] && source "$HOME/.zshrc.local"

true

## vim:fdm=expr:fdl=0:fdc=3:et:sts=4:ts=4:sw=4
## vim:fde=getline(v\:lnum)=~'^##'?'>'.(matchend(getline(v\:lnum),'##*')-2)\:'='

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
